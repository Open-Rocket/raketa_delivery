import os
import asyncio
import logging

from aiogram import Router, F
from aiogram.types import (
    Message,
    CallbackQuery,
    ReplyKeyboardRemove,
    LabeledPrice,
    PreCheckoutQuery,
)
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.enums import ContentType
from aiogram import filters
from aiogram import Bot

from app.c_pack.c_middlewares import OuterMiddleware, InnerMiddleware
from app.c_pack.c_states import CourierState, CourierRegistration
from app.common.message_handler import MessageHandler
from app.common.titles import get_image_title_courier
from app.common.titles import get_image_title_courier
from app.c_pack.c_kb import get_courier_kb, get_my_orders_kb
from app.database.models import OrderStatus

from app.database.requests import courier_data, order_data, user_data

from datetime import datetime
from dotenv import load_dotenv

load_dotenv()

couriers_router = Router()

couriers_router.message.outer_middleware(OuterMiddleware())
couriers_router.callback_query.outer_middleware(OuterMiddleware())

couriers_router.message.middleware(InnerMiddleware())
couriers_router.callback_query.middleware(InnerMiddleware())

notification_bot = Bot(token=os.getenv("U_TOKEN"))
logger = logging.getLogger(__name__)


# main
# -----------------------------------------------------------------------------


@couriers_router.message(
    F.content_type == ContentType.LOCATION, filters.StateFilter(CourierState.location)
)
async def get_location(message: Message, state: FSMContext) -> None:
    handler = MessageHandler(state, message.bot)
    await handler.delete_previous_message(message.chat.id)

    courier_tg_id = message.from_user.id
    my_lon = message.location.longitude
    my_lat = message.location.latitude
    radius_km = 5

    # Получаем доступные заказы
    available_orders = await order_data.get_available_orders(
        courier_tg_id, my_lat, my_lon, radius_km=radius_km
    )

    orders = []
    order_ids = []

    for index, order in enumerate(available_orders, start=1):
        order_ids.append(order.order_id)

        order_forma = (
            f"<b>{index}/{len(available_orders)}</b>\n"
            f"<b>Заказ: №{order.order_id}</b>\n"
            f"---------------------------------------------\n\n"
            f"<b>Город:</b> {order.order_city}\n\n"
            f"<b>Заказчик:</b> {order.customer_name}\n"
            f"<b>Телефон:</b> <i>*Доступен после принятия.</i>\n\n"
            f"⦿ <b>Адрес 1:</b> <a href='{order.a_url}'>{order.starting_point_a}</a>\n"
        )

        if order.destination_point_b:
            order_forma += f"⦿ <b>Адрес 2:</b> <a href='{order.b_url}'>{order.destination_point_b}</a>\n"
        if order.destination_point_c:
            order_forma += f"⦿ <b>Адрес 3:</b> <a href='{order.c_url}'>{order.destination_point_c}</a>\n"

        order_forma += (
            f"\n<b>Доставляем:</b> {order.delivery_object if order.delivery_object else '...'}\n"
            f"<b>Расстояние:</b> {order.distance_km} км\n"
            f"<b>Стоимость доставки:</b> {order.price_rub}₽\n\n"
            f"<b>Описание:</b> <i>{'*'}{order.description if order.description else '...'}</i>\n\n"
            f"---------------------------------------------\n"
            f"• Принимайте оплату наличными или переводом.\n\n"
            f"<a href='{order.full_rout}'>Маршрут доставки</a>\n\n"
        )

        orders.append(order_forma)

    if not orders:
        await asyncio.sleep(1)
        new_message = await message.answer(
            "Нет доступных заказов в вашем радиусе.", disable_notification=True
        )
        await handler.handle_new_message(new_message, message)
        return

    counter = 0
    await state.update_data(orders=orders, order_ids=order_ids, counter=counter)

    # Логируем перед отправкой
    logger.info(
        f"Курьер {courier_tg_id} видит {len(orders)} доступных заказов. Показан первый заказ с индексом {counter}."
    )

    reply_kb = await get_courier_kb(
        text="one_order" if len(orders) == 1 else "available_orders"
    )

    await asyncio.sleep(1)
    handler = MessageHandler(state, message.bot)
    new_message = await message.answer(
        orders[counter],
        reply_markup=reply_kb,
        parse_mode="HTML",
        disable_notification=True,
    )
    await handler.handle_new_message(new_message, message)

    # Логируем, что сообщение отправлено
    logger.info(f"Курьер {courier_tg_id} получил сообщение о первом заказе.")


@couriers_router.callback_query(F.data == "accept_order")
async def accept_order(callback_query: CallbackQuery, state: FSMContext):
    # Получаем текущие данные состояния
    data = await state.get_data()
    order_ids = data.get("order_ids", [])
    counter = data.get("counter", 0)
    courier_tg_id = callback_query.from_user.id

    # Логирование данных перед обработкой
    logger.info(f"Курьер {courier_tg_id} нажал на кнопку 'Принять заказ'.")
    logger.info(f"Заказов найдено: {len(order_ids)}, текущий индекс: {counter}")

    # Проверка наличия заказов
    if not order_ids:
        logger.warning(f"Курьер {courier_tg_id} не имеет доступных заказов.")
        await callback_query.answer("Заказы не найдены.", show_alert=True)
        return

    # Проверка на правильность индекса
    if counter >= len(order_ids):
        logger.warning(
            f"Курьер {courier_tg_id} передал неверный индекс для заказа: {counter}."
        )
        await callback_query.answer("Неверный индекс для заказа.", show_alert=True)
        return

    order_id = order_ids[counter]
    logger.info(f"Курьер {courier_tg_id} принял заказ с ID: {order_id}.")

    try:
        # Назначаем курьера к заказу
        logger.info(f"Назначаем курьера {courier_tg_id} на заказ с ID {order_id}.")
        await order_data.assign_courier_to_order(
            order_id=order_id, courier_tg_id=courier_tg_id
        )

        # Обновляем статус заказа на "В работе"
        logger.info(f"Обновляем статус заказа {order_id} на 'В работе'.")
        await order_data.update_order_status(
            order_id=order_id, new_status=OrderStatus.IN_PROGRESS
        )

        # Получаем номер телефона заказчика
        customer_phone = await order_data.get_order_customer_phone(order_id)
        logger.info(
            f"Получен номер телефона заказчика для заказа {order_id}: {customer_phone}"
        )

        # Получаем tg_id по номеру телефона
        customer_tg_id = await user_data.get_user_tg_id_by_phone(customer_phone)
        logger.info(f"Получен tg_id заказчика: {customer_tg_id}")

        # Отправляем уведомление заказчику
        notification_text = (
            f"Ваш заказ №{order_id} был принят курьером!\n"
            f"Подробности смотрите в Моих заказах\n\n"
            f"<i>*Сообщение удалится через 15 минут</i>"
        )
        notification_message = await notification_bot.send_message(
            chat_id=customer_tg_id, text=notification_text, parse_mode="HTML"
        )
        logger.info(
            f"Отправлено уведомление заказчику {customer_tg_id} о принятии заказа."
        )

        # Уведомляем курьера о принятии заказа
        new_message = await callback_query.message.answer(
            "Заказ принят. Вы закреплены за этим заказом.",
            parse_mode="HTML",
            disable_notification=False,
        )
        logger.info(f"Уведомление курьеру {courier_tg_id}: 'Заказ принят'.")

        # Обновляем состояние
        await state.set_state(CourierState.default)

        handler = MessageHandler(state, callback_query.message.bot)
        await handler.handle_new_message(new_message, callback_query.message)

        # Удаляем уведомление спустя 1 час
        await asyncio.sleep(900)  # Ожидаем 15 минут
        try:
            await notification_bot.delete_message(
                chat_id=customer_tg_id, message_id=notification_message.message_id
            )
            logger.info(
                f"Удалено уведомление для заказчика {customer_tg_id} с ID сообщения {notification_message.message_id}."
            )
        except Exception as e:
            logger.error(f"Ошибка при удалении сообщения: {e}")

    except ValueError as e:
        logger.error(f"ValueError при принятии заказа {order_id}: {e}")
        await callback_query.answer(str(e), show_alert=True)
    except Exception as e:
        logger.error(f"Ошибка при принятии заказа {order_id}: {e}")
        await callback_query.answer("Ошибка при принятии заказа.", show_alert=True)


@couriers_router.callback_query(
    F.data.in_({"active_orders", "completed_orders", "next_order", "prev_order"})
)
async def get_courier_orders(callback_query: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    courier_tg_id = callback_query.from_user.id

    if callback_query.data in {"next_order", "prev_order"}:
        counter = data.get("counter", 0)
        orders_text = data.get("orders_text", [])
        total_orders = len(orders_text)

        if total_orders == 0:
            await callback_query.answer("Нет доступных заказов.", show_alert=True)
            logger.warning(
                f"Курьер {courier_tg_id} пытается прокрутить заказы, но у него их нет."
            )
            return

        counter = (
            (counter + 1) % total_orders
            if callback_query.data == "next_order"
            else (counter - 1) % total_orders
        )
        await state.update_data(counter=counter)
        logger.info(
            f"Курьер {courier_tg_id} прокрутил заказ на {counter+1}/{total_orders}."
        )

        reply_kb = await get_courier_kb(
            text="active_one" if data.get("status") == "active" else "complete_one"
        )

        await callback_query.message.edit_text(
            orders_text[counter],
            reply_markup=reply_kb,
            parse_mode="HTML",
            disable_notification=True,
        )
        return

    order_type = callback_query.data
    order_status_mapping = {
        "active_orders": (
            order_data.get_active_orders,
            CourierState.myOrders_active,
            "активных",
            "active",
        ),
        "completed_orders": (
            order_data.get_completed_orders,
            CourierState.myOrders_completed,
            "завершённых",
            "completed",
        ),
    }

    get_orders_func, state_status, status_text, status_key = order_status_mapping.get(
        order_type, (None, None, "", "")
    )

    if not get_orders_func:
        await callback_query.answer("Ошибка запроса заказов.", show_alert=True)
        logger.error(
            f"Неизвестный запрос типа {order_type} от курьера {courier_tg_id}."
        )
        return

    try:
        # Получаем все заказы для курьера
        courier_orders = await get_orders_func(courier_tg_id)
        logger.info(
            f"Курьер {courier_tg_id} получил {len(courier_orders)} заказов из БД."
        )

        if not courier_orders:
            await callback_query.message.edit_text(
                f"У вас нет {status_text} заказов.",
                reply_markup=await get_courier_kb(text="go_back"),
                disable_notification=True,
            )
            return

        filtered_orders = []
        for order in courier_orders:
            logger.info(
                f"Обрабатываю заказ {order.order_id}, статус: {order.order_status}"
            )

            if order.order_status == (
                OrderStatus.IN_PROGRESS
                if status_key == "active"
                else OrderStatus.COMPLETED
            ):
                filtered_orders.append(order)
            else:
                logger.warning(
                    f"Заказ {order.order_id} пропущен, его статус не соответствует {status_key}."
                )

        if not filtered_orders:
            await callback_query.message.edit_text(
                f"У вас нет {status_text} заказов.",
                reply_markup=await get_courier_kb(text="go_back"),
                disable_notification=True,
            )
            logger.info(
                f"Курьер {courier_tg_id} не имеет заказов с нужным статусом {status_key}."
            )
            return

        await state.set_state(state_status)

        # Формируем текст для заказов
        orders_text = []
        for index, order in enumerate(filtered_orders, start=1):
            order_forma = (
                f"<b>{index}/{len(filtered_orders)}</b>\n"
                f"<b>Заказ: №{order.order_id}</b>\n"
                f"---------------------------------------------\n\n"
                f"<b>Город:</b> {order.order_city}\n\n"
                f"<b>Заказчик:</b> {order.customer_name}\n"
                f"<b>Телефон:</b> {order.customer_phone}\n\n"
                f"⦿ <b>Адрес 1:</b> <a href='{order.a_url}'>{order.starting_point_a}</a>\n"
            )

            # Список адресов
            delivery_points = [
                (order.destination_point_b, order.b_url),
                (order.destination_point_c, order.c_url),
                (order.destination_point_d, order.d_url),
                (order.destination_point_e, order.e_url),
            ]

            for i, (point, url) in enumerate(delivery_points, start=2):
                if point:
                    order_forma += f"⦿ <b>Адрес {i}:</b> <a href='{url}'>{point}</a>\n"

            order_forma += (
                f"\n<b>Доставляем:</b> {order.delivery_object if order.delivery_object else '...'}\n"
                f"<b>Расстояние:</b> {order.distance_km} км\n"
                f"<b>Стоимость доставки:</b> {order.price_rub}₽\n\n"
                f"<b>Описание:</b> {order.description if order.description else '...'}\n\n"
                f"---------------------------------------------\n"
                f"• Принимайте оплату наличными или переводом.\n\n"
                f"⦿ <a href='{order.full_rout}'>Маршрут доставки</a>\n"
            )

            orders_text.append(order_forma)

        # Сохраняем обновленные данные в состоянии
        await state.update_data(orders_text=orders_text, counter=0)
        logger.info(
            f"Для курьера {courier_tg_id} подготовлено {len(orders_text)} заказов."
        )

        reply_kb = await get_courier_kb(
            text=(
                "active_one"
                if status_key == "active" and len(orders_text) == 1
                else (
                    "active_orders"
                    if status_key == "active"
                    else "complete_one" if len(orders_text) == 1 else "complete_orders"
                )
            )
        )

        # Отправляем первый заказ или сообщение о пустом статусе
        await callback_query.message.edit_text(
            orders_text[0],
            reply_markup=reply_kb,
            parse_mode="HTML",
            disable_notification=True,
        )

    except Exception as e:
        logger.error(
            f"Ошибка при обработке заказов для курьера {courier_tg_id}: {str(e)}"
        )
        await callback_query.answer(
            "Произошла ошибка при загрузке заказов. Попробуйте позже.", show_alert=True
        )


@couriers_router.callback_query(F.data == "order_delivered")
async def complete_order(callback_query: CallbackQuery, state: FSMContext):
    handler = MessageHandler(state, callback_query.message.bot)
    data = await state.get_data()
    current_order_id = data.get("current_order_id")

    logger.info(f"Состояние перед завершением заказа: {data}")
    logger.info(f"current_order_id: {current_order_id}")

    # Проверка наличия активного заказа
    if not current_order_id:
        await callback_query.message.answer(
            "Не удалось найти активный заказ для завершения."
        )
        return

    try:
        # Загружаем АКТУАЛЬНЫЙ статус заказа без кэша
        order = await order_data.get_order_by_id(current_order_id)
        logger.info(
            f"Попытка завершить заказ {current_order_id}, его статус: {order.order_status}"
        )

        # Проверка, что заказ ещё в процессе выполнения
        if order.order_status != OrderStatus.IN_PROGRESS:
            await callback_query.message.answer(
                f"Заказ №{current_order_id} уже завершён или находится в другом статусе. Статус: {order.order_status}.",
                parse_mode="HTML",
            )
            return

        # Обновляем статус заказа
        completed_time = datetime.now()
        await order_data.update_order_status_and_time(
            order_id=current_order_id,
            new_status=OrderStatus.COMPLETED,
            completed_time=completed_time,
        )

        # Получаем данные заказчика
        customer_phone = await order_data.get_order_customer_phone(current_order_id)
        customer_tg_id = await user_data.get_user_tg_id_by_phone(customer_phone)

        # Уведомляем заказчика
        notification_text = (
            f"Ваш заказ №{current_order_id} был успешно доставлен курьером!\n"
            f"Спасибо, что воспользовались нашим сервисом.\n\n"
            f"<i>*Сообщение удалится через 15 минут</i>"
        )
        notification_message = await notification_bot.send_message(
            chat_id=customer_tg_id, text=notification_text, parse_mode="HTML"
        )

        # Уведомляем курьера
        await callback_query.message.answer(
            f"Статус заказа №{current_order_id} обновлен на 'Завершен'. Заказчик уведомлен.",
            parse_mode="HTML",
            disable_notification=False,
        )

        # Удаляем предыдущее сообщение курьера
        await handler.delete_previous_message(callback_query.message.chat.id)

        # Устанавливаем состояние курьера в начальное состояние
        await state.set_state(CourierState.default)

        # Удаляем уведомление заказчику через 15 минут
        await asyncio.sleep(900)
        try:
            await notification_bot.delete_message(
                chat_id=customer_tg_id, message_id=notification_message.message_id
            )
        except Exception as e:
            logger.error(f"Ошибка при удалении сообщения заказчику: {e}")

    except ValueError as e:
        await callback_query.answer(str(e), show_alert=True)
    except Exception as e:
        await callback_query.answer("Ошибка при завершении заказа.", show_alert=True)
        logger.error(f"Ошибка при завершении заказа: {e}")


# previous
# -----------------------------------------------------------------------------


@couriers_router.message(
    F.content_type == ContentType.LOCATION, filters.StateFilter(CourierState.location)
)
async def get_location2(message: Message, state: FSMContext) -> None:
    handler = MessageHandler(state, message.bot)
    await handler.delete_previous_message(message.chat.id)

    courier_tg_id = message.from_user.id
    my_lon = message.location.longitude
    my_lat = message.location.latitude
    radius_km = 5

    available_orders = await order_data.get_available_orders(
        courier_tg_id, my_lat, my_lon, radius_km=radius_km
    )

    def format_address(number, address, name, phone, url):
        return (
            f"⦿ Адрес {number}: <a href='{url}'>{address}</a>\n"
            f"Имя: {name if name else '-'}\n"
            f"Телефон: {phone if phone else '-'}\n\n"
        )

    orders = []
    order_ids = []  # Список для хранения order_id

    for index, order in enumerate(available_orders, start=1):
        order_ids.append(order.order_id)

        order_forma = (
            f"<b>{index}/{len(available_orders)}</b>\n"
            f"<b>Заказ: №{order.order_id}</b>\n"
            f"---------------------------------------------\n\n"
            f"<b>Город:</b> {order.order_city}\n\n"
            f"<b>Заказчик:</b> {order.customer_name}\n"
            f"<b>Телефон:</b> <i>*Доступен после принятия.</i>\n\n"
            f"⦿ <b>Адрес 1:</b> <a href='{order.a_url}'>{order.starting_point_a}</a>\n"
        )

        if order.destination_point_b:
            order_forma += f"⦿ <b>Адрес 2:</b> <a href='{order.b_url}'>{order.destination_point_b}</a>\n"
        if order.destination_point_c:
            order_forma += f"⦿ <b>Адрес 3:</b> <a href='{order.c_url}'>{order.destination_point_c}</a>\n"

        order_forma += (
            f"\n<b>Доставляем:</b> {order.delivery_object if order.delivery_object else '...'}\n"
            f"<b>Расстояние:</b> {order.distance_km} км\n"
            f"<b>Стоимость доставки:</b> {order.price_rub}₽\n\n"
            f"<b>Описание:</b> <i>{'*'}{order.description if order.description else '...'}</i>\n\n"
            f"---------------------------------------------\n"
            f"• Принимайте оплату наличными или переводом.\n\n"
            f"<a href='{order.full_rout}'>Маршрут доставки</a>\n\n"
        )

        orders.append(order_forma)

    if not orders:
        # await message.answer("Спасибо! Локация получена.", reply_markup=ReplyKeyboardRemove())
        await asyncio.sleep(1)
        new_message = await message.answer(
            "Нет доступных заказов в вашем радиусе.", disable_notification=True
        )
        await handler.handle_new_message(new_message, message)
        return

    # Сохраняем заказы и идентификаторы заказов
    counter = 0
    await state.update_data(orders=orders, order_ids=order_ids, counter=counter)

    # Отправляем первый заказ
    reply_kb = await get_courier_kb(
        text="one_order" if len(orders) == 1 else "available_orders"
    )

    await asyncio.sleep(1)
    handler = MessageHandler(state, message.bot)
    new_message = await message.answer(
        orders[counter],
        reply_markup=reply_kb,
        parse_mode="HTML",
        disable_notification=True,
    )
    await handler.handle_new_message(new_message, message)


@couriers_router.callback_query(F.data == "accept_order")
async def accept_order2(callback_query: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    order_ids = data.get("order_ids", [])
    counter = data.get("counter", 0)
    courier_tg_id = callback_query.from_user.id

    if not order_ids:
        await callback_query.answer("Заказы не найдены.", show_alert=True)
        return

    order_id = order_ids[counter]

    try:
        # Назначаем курьера к заказу
        await order_data.assign_courier_to_order(
            order_id=order_id, courier_tg_id=courier_tg_id
        )

        # Обновляем статус заказа на "В работе"
        await order_data.update_order_status(
            order_id=order_id, new_status=OrderStatus.IN_PROGRESS
        )

        # Получаем номер телефона заказчика
        customer_phone = await order_data.get_order_customer_phone(order_id)

        # Получаем tg_id по номеру телефона
        customer_tg_id = await user_data.get_user_tg_id_by_phone(customer_phone)

        # Отправляем уведомление заказчику
        notification_text = (
            f"Ваш заказ №{order_id} был принят курьером!\n"
            f"Подробности смотрите в Моих заказах\n\n"
            f"<i>*Сообщение удалится через 15 минут</i>"
        )
        notification_message = await notification_bot.send_message(
            chat_id=customer_tg_id, text=notification_text, parse_mode="HTML"
        )

        # Уведомляем курьера о принятии заказа
        new_message = await callback_query.message.answer(
            "Заказ принят. Вы закреплены за этим заказом.",
            parse_mode="HTML",
            disable_notification=False,
        )
        await state.set_state(CourierState.default)

        handler = MessageHandler(state, callback_query.message.bot)
        await handler.handle_new_message(new_message, callback_query.message)

        # Удаляем уведомление спустя 1 час
        await asyncio.sleep(900)  # Ожидаем 1 час
        try:
            await notification_bot.delete_message(
                chat_id=customer_tg_id, message_id=notification_message.message_id
            )
        except Exception as e:
            logger.error(f"Ошибка при удалении сообщения: {e}")

    except ValueError as e:
        await callback_query.answer(str(e), show_alert=True)
    except Exception as e:
        await callback_query.answer("Ошибка при принятии заказа.", show_alert=True)
        logger.error(f"Ошибка: {e}")


@couriers_router.callback_query(
    F.data.in_({"active_orders", "completed_orders", "next_order", "prev_order"})
)
async def get_courier_orders2(callback_query: CallbackQuery, state: FSMContext):
    data = await state.get_data()

    # Если курьер листает заказы (вперёд или назад)
    if callback_query.data in {"next_order", "prev_order"}:
        counter = data.get("counter", 0)
        orders_text = data.get("orders_text", [])

        # Переключение по заказам (вперёд или назад) с циклическим зацикливанием
        if orders_text:
            total_orders = len(orders_text)
            if callback_query.data == "next_order":
                counter = (counter + 1) % total_orders
            elif callback_query.data == "prev_order":
                counter = (counter - 1) % total_orders

            await state.update_data(counter=counter)
            reply_kb = await get_courier_kb(text="one_my_order")
            await callback_query.message.edit_text(
                orders_text[counter],
                reply_markup=reply_kb,
                parse_mode="HTML",
                disable_notification=True,
            )
        return

    # Основная логика получения заказов
    order_type = callback_query.data
    courier_tg_id = callback_query.from_user.id

    if order_type == "active_orders":
        courier_orders = await order_data.get_active_orders(courier_tg_id)
        await state.set_state(CourierState.myOrders_active)
        status_text = "активных"
    elif order_type == "completed_orders":
        courier_orders = await order_data.get_completed_orders(courier_tg_id)
        await state.set_state(CourierState.myOrders_completed)
        status_text = "завершенных"

    # Проверяем наличие заказов и настраиваем клавиатуру соответственно
    num_orders = len(courier_orders)
    if num_orders == 0:
        text = f"У вас нет {status_text} заказов."
        reply_kb = await get_courier_kb(text="empty_orders")
        await callback_query.message.edit_text(
            text, reply_markup=reply_kb, disable_notification=True
        )
        return
    elif num_orders == 1:
        keyboard_type = (
            "active_one" if order_type == "active_orders" else "complete_one"
        )
    else:
        keyboard_type = (
            "active_orders" if order_type == "active_orders" else "complete_orders"
        )

    # Формируем текст для каждого заказа
    def format_address(number, address, name, phone, url):
        return (
            f"⦿ <b>Адрес {number}:</b> <a href='{url}'>{address}</a>\n"
            f"<b>Имя:</b> {name if name else '-'}\n"
            f"<b>Телефон:</b> {phone if phone else '-'}\n\n"
        )

    # Сохраняем текст каждого заказа и сам `orders` как словарь
    orders_text = []
    orders_dict = {}  # Храним заказы в виде словаря с ID в качестве ключей
    for order in courier_orders:
        base_info = (
            f"{courier_orders.index(order) + 1}/{len(courier_orders)}\n\n"
            f"<b>Заказ №{order.order_id}</b>\n"
            f"<b>Дата оформления:</b> {order.created_at_moscow_time}\n"
            f"<b>Статус заказа:</b> {order.order_status.value}\n"
            f"---------------------------------------------\n"
            f"<b>Город:</b> {order.order_city}\n\n"
            f"{format_address(1, order.starting_point_a, order.sender_name, order.sender_phone, order.a_url)}"
        )

        if order.destination_point_b:
            base_info += format_address(
                2,
                order.destination_point_b,
                order.receiver_name_1,
                order.receiver_phone_1,
                order.b_url,
            )
        if order.destination_point_c:
            base_info += format_address(
                3,
                order.destination_point_c,
                order.receiver_name_2,
                order.receiver_phone_2,
                order.c_url,
            )
        if order.destination_point_d:
            base_info += format_address(
                4,
                order.destination_point_d,
                order.receiver_name_3,
                order.receiver_phone_3,
                order.d_url,
            )
        if order.destination_point_e:
            base_info += format_address(
                5,
                order.destination_point_e,
                order.receiver_name_4,
                order.receiver_phone_4,
                order.e_url,
            )

        base_info += (
            f"<b>Доставляем:</b> {order.delivery_object if order.delivery_object else '-'}\n\n"
            f"<b>Расстояние:</b> {order.distance_km} км\n"
            f"<b>Стоимость доставки:</b> {order.price_rub}₽\n"
            f"---------------------------------------------\n"
            f"<b>Комментарии:</b> <i>{'*'}{order.comments if order.comments else '...'}</i>\n\n"
            f"⦿⌁⦿ <a href='{order.full_rout}'>Маршрут</a>\n\n"
        )

        orders_text.append(base_info)
        orders_dict[order.order_id] = order  # Сохраняем каждый заказ по его ID

    # Устанавливаем данные для состояния
    counter = 0
    current_order_id = courier_orders[counter].order_id
    await state.update_data(
        orders_text=orders_text,
        orders=orders_dict,
        counter=counter,
        current_order_id=current_order_id,
    )

    # Устанавливаем соответствующую клавиатуру
    reply_kb = await get_courier_kb(text=keyboard_type)
    await callback_query.message.edit_text(
        orders_text[counter],
        reply_markup=reply_kb,
        parse_mode="HTML",
        disable_notification=True,
    )


@couriers_router.callback_query(F.data == "order_delivered")
async def complete_order2(callback_query: CallbackQuery, state: FSMContext):
    handler = MessageHandler(state, callback_query.message.bot)
    data = await state.get_data()
    current_order_id = data.get("current_order_id")  # Получаем ID текущего заказа

    if not current_order_id:
        await callback_query.message.answer(
            "Не удалось найти активный заказ для завершения."
        )
        return

    try:
        # Проверяем текущий статус заказа
        order = await order_data.get_order_by_id(current_order_id)
        if order.order_status != OrderStatus.IN_PROGRESS:
            await callback_query.message.answer(
                f"Заказ №{current_order_id} нельзя завершить, так как он не в статусе выполнения."
            )
            return

        # Обновляем статус заказа на "Завершен" и устанавливаем время завершения в базе данных
        completed_time = datetime.now()  # Текущее время завершения
        await order_data.update_order_status_and_time(
            order_id=current_order_id,
            new_status=OrderStatus.COMPLETED,
            completed_time=completed_time,
        )

        # Получаем данные заказчика для отправки уведомления
        customer_phone = await order_data.get_order_customer_phone(current_order_id)
        customer_tg_id = await user_data.get_user_tg_id_by_phone(customer_phone)

        # Отправляем уведомление заказчику
        notification_text = (
            f"Ваш заказ №{current_order_id} был успешно доставлен курьером!\n"
            f"Спасибо, что воспользовались нашим сервисом.\n\n"
            f"<i>*Сообщение удалится через 15 минут</i>"
        )
        notification_message = await notification_bot.send_message(
            chat_id=customer_tg_id, text=notification_text, parse_mode="HTML"
        )

        # Уведомляем курьера о завершении заказа
        await callback_query.message.answer(
            "Статус заказа обновлен на 'Завершен'. Заказчик уведомлен.",
            parse_mode="HTML",
            disable_notification=False,
        )

        # Удаляем предыдущее сообщение курьера перед отправкой нового
        await handler.delete_previous_message(callback_query.message.chat.id)

        # Устанавливаем состояние курьера в начальное состояние
        await state.set_state(CourierState.default)

        # Удаляем уведомление заказчику через 15 минут
        await asyncio.sleep(900)
        try:
            await notification_bot.delete_message(
                chat_id=customer_tg_id, message_id=notification_message.message_id
            )
        except Exception as e:
            logger.error(f"Ошибка при удалении сообщения заказчику: {e}")

    except ValueError as e:
        await callback_query.answer(str(e), show_alert=True)
    except Exception as e:
        await callback_query.answer("Ошибка при завершении заказа.", show_alert=True)
        logger.error(f"Ошибка при завершении заказа: {e}")
